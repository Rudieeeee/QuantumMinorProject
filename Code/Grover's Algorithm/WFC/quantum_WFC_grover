import random
import numpy as np
from PIL import Image

from qiskit import QuantumCircuit
from qiskit_aer import AerSimulator

# ======================================================
# TILE SET
# ======================================================
TILES = ["grass", "sand", "water", "forest", "rock"]

ADJACENCY = {
    "grass": {"grass", "sand", "forest"},
    "sand": {"grass", "sand", "water"},
    "water": {"sand", "water"},
    "forest": {"grass", "forest", "rock"},
    "rock": {"forest", "rock"},
}

COLORS = {
    "grass": (34, 139, 34),
    "sand": (194, 178, 128),
    "water": (30, 144, 255),
    "forest": (0, 100, 0),
    "rock": (110, 110, 110),
}

GRID_W, GRID_H = 15, 15
CELL_SIZE = 50

# ======================================================
# CLASSICAL WFC UTILS
# ======================================================
def new_grid():
    return [[set(TILES) for _ in range(GRID_W)] for _ in range(GRID_H)]


def neighbors(x, y):
    for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)]:
        nx, ny = x + dx, y + dy
        if 0 <= nx < GRID_W and 0 <= ny < GRID_H:
            yield nx, ny


def entropy(cell):
    return len(cell)

# ======================================================
# GROVER TILE SELECTION
# ======================================================
def grover_choose_tile(grid, x, y):
    """
    Grover search over tile indices.
    Marks all tiles compatible with neighbors.
    """

    # ---- determine valid tiles classically ----
    valid_tiles = set(TILES)

    for nx, ny in neighbors(x, y):
        if len(grid[ny][nx]) == 1:
            neighbor = next(iter(grid[ny][nx]))
            valid_tiles &= ADJACENCY[neighbor]

    if not valid_tiles:
        return random.choice(list(grid[y][x]))

    # ---- map tiles to indices ----
    tile_indices = {i: t for i, t in enumerate(TILES)}
    valid_indices = [i for i, t in tile_indices.items() if t in valid_tiles]

    num_qubits = 3  # 3 bits = 8 states (enough for 5 tiles)
    qc = QuantumCircuit(num_qubits, num_qubits)

    # ---- superposition ----
    qc.h(range(num_qubits))

    # ---- oracle: phase flip valid states ----
    for idx in valid_indices:
        bits = format(idx, "03b")
        for i, b in enumerate(bits):
            if b == "0":
                qc.x(i)
        qc.h(2)
        qc.ccx(0, 1, 2)
        qc.h(2)
        for i, b in enumerate(bits):
            if b == "0":
                qc.x(i)

    # ---- diffusion operator ----
    qc.h(range(num_qubits))
    qc.x(range(num_qubits))
    qc.h(2)
    qc.ccx(0, 1, 2)
    qc.h(2)
    qc.x(range(num_qubits))
    qc.h(range(num_qubits))

    # ---- measure ----
    qc.measure(range(num_qubits), range(num_qubits))

    sim = AerSimulator()
    result = sim.run(qc, shots=512).result()
    counts = result.get_counts()

    # ---- choose most frequent valid state ----
    best_idx = None
    best_count = -1

    for bitstring, count in counts.items():
        idx = int(bitstring[::-1], 2)
        if idx in valid_indices and count > best_count:
            best_count = count
            best_idx = idx

    if best_idx is not None:
        return TILES[best_idx]

    return random.choice(list(grid[y][x]))

# ======================================================
# PROPAGATION
# ======================================================
def propagate(grid, start):
    stack = [start]
    while stack:
        x, y = stack.pop()
        current = grid[y][x]

        for nx, ny in neighbors(x, y):
            allowed = set()
            for t in current:
                allowed |= ADJACENCY[t]

            before = grid[ny][nx]
            after = before & allowed

            if not after:
                return False

            if after != before:
                grid[ny][nx] = after
                stack.append((nx, ny))

    return True

# ======================================================
# COLLAPSE
# ======================================================
def collapse(grid):
    cells = [
        (x, y)
        for y in range(GRID_H)
        for x in range(GRID_W)
        if len(grid[y][x]) > 1
    ]

    if not cells:
        return True

    x, y = min(cells, key=lambda c: entropy(grid[c[1]][c[0]]))
    grid[y][x] = {grover_choose_tile(grid, x, y)}
    return propagate(grid, (x, y))

# ======================================================
# RUN WFC
# ======================================================
def run_wfc():
    while True:
        grid = new_grid()
        ok = True
        while ok:
            if all(len(grid[y][x]) == 1 for y in range(GRID_H) for x in range(GRID_W)):
                return grid
            ok = collapse(grid)

# ======================================================
# RENDER
# ======================================================
def render(grid):
    img = Image.new("RGB", (GRID_W * CELL_SIZE, GRID_H * CELL_SIZE))
    for y in range(GRID_H):
        for x in range(GRID_W):
            tile = next(iter(grid[y][x]))
            color = COLORS[tile]
            for dy in range(CELL_SIZE):
                for dx in range(CELL_SIZE):
                    img.putpixel((x*CELL_SIZE+dx, y*CELL_SIZE+dy), color)
    img.show()
    img.save("grover_wfc.png")

# ======================================================
# MAIN
# ======================================================
if __name__ == "__main__":
    grid = run_wfc()
    render(grid)
