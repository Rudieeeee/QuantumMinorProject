import numpy as np
import matplotlib.pyplot as plt
from qiskit import QuantumCircuit
from qiskit_aer import Aer
from qiskit.visualization import plot_histogram

# ============================================
# CONFIGURE YOUR GRID SIZE HERE
# ============================================
GRID_ROWS = 2  # Number of rows (n)
GRID_COLS = 3  # Number of columns (m)
# ============================================

# --------------------------------------------------
# Tile decoding
# --------------------------------------------------
TILE_MAP = {
    "00": "Water",
    "01": "Sand",
    "10": "Grass",
    "11": "Jungle"
}

COLOR_MAP = {
    "Water": (0.2, 0.4, 1.0),
    "Sand": (0.9, 0.85, 0.6),
    "Grass": (0.2, 0.7, 0.2),
    "Jungle": (0.0, 0.4, 0.0)
}

# --------------------------------------------------
# Valid adjacency lookup
# --------------------------------------------------
VALID = {
    "Water": {"Water", "Sand"},
    "Sand": {"Water", "Sand", "Grass"},
    "Grass": {"Sand", "Grass", "Jungle"},
    "Jungle": {"Grass", "Jungle"}
}

# --------------------------------------------------
# Helper: compare two 2-qubit tiles
# --------------------------------------------------
def invalid_pair(tile_a, tile_b):
    return tile_b not in VALID[tile_a]

# --------------------------------------------------
# Generate adjacency pairs for n×m grid
# --------------------------------------------------
def get_adjacencies(rows, cols):
    adjacencies = []
    
    # Horizontal adjacencies (left to right)
    for row in range(rows):
        for col in range(cols - 1):
            left = row * cols + col
            right = row * cols + col + 1
            adjacencies.append((left, right))
    
    # Vertical adjacencies (top to bottom)
    for row in range(rows - 1):
        for col in range(cols):
            top = row * cols + col
            bottom = (row + 1) * cols + col
            adjacencies.append((top, bottom))
    
    return adjacencies

# --------------------------------------------------
# Calculate optimal Grover iterations
# --------------------------------------------------
def calculate_iterations(num_tiles):
    # Heuristic: sqrt(search_space) / constant
    # For small grids (≤9 tiles): use formula
    # For larger grids: cap at reasonable limit
    search_space = 2 ** (num_tiles * 2)
    
    if num_tiles <= 4:
        return max(3, int(np.pi / 4 * np.sqrt(search_space) / 20))
    elif num_tiles <= 9:
        return max(8, int(np.pi / 4 * np.sqrt(search_space) / 100))
    else:
        # For very large grids, use a conservative estimate
        return min(20, max(10, int(np.sqrt(num_tiles) * 2)))

# --------------------------------------------------
# Oracle: mark ONLY invalid grids (flip phase)
# --------------------------------------------------
def grover_oracle(qc, data, flag, adjacencies):
    for a, b in adjacencies:
        for ta in TILE_MAP:
            for tb in TILE_MAP:
                if invalid_pair(TILE_MAP[ta], TILE_MAP[tb]):
                    idx = []
                    for i, bit in enumerate(ta):
                        if bit == "0":
                            qc.x(data[2*a+i])
                        idx.append(data[2*a+i])
                    for i, bit in enumerate(tb):
                        if bit == "0":
                            qc.x(data[2*b+i])
                        idx.append(data[2*b+i])

                    qc.mcx(idx, flag)

                    for i, bit in enumerate(ta):
                        if bit == "0":
                            qc.x(data[2*a+i])
                    for i, bit in enumerate(tb):
                        if bit == "0":
                            qc.x(data[2*b+i])

# --------------------------------------------------
# Diffusion
# --------------------------------------------------
def diffuser(qc, qubits):
    qc.h(qubits)
    qc.x(qubits)
    qc.h(qubits[-1])
    qc.mcx(qubits[:-1], qubits[-1])
    qc.h(qubits[-1])
    qc.x(qubits)
    qc.h(qubits)

# --------------------------------------------------
# Validate solution
# --------------------------------------------------
def is_valid_grid(bitstring, adjacencies):
    tiles = [bitstring[i:i+2] for i in range(0, len(bitstring), 2)]
    decoded = [TILE_MAP[t] for t in tiles]
    
    for a, b in adjacencies:
        if decoded[b] not in VALID[decoded[a]]:
            return False
    return True

# --------------------------------------------------
# Main execution
# --------------------------------------------------
def run_wfc_grover(rows, cols):
    num_tiles = rows * cols
    num_data_qubits = num_tiles * 2
    num_qubits = num_data_qubits + 1
    
    print("="*60)
    print(f"Wave Function Collapse with Grover's Algorithm")
    print("="*60)
    print(f"Grid size: {rows}×{cols} ({num_tiles} tiles)")
    print(f"Total qubits: {num_qubits} ({num_data_qubits} data + 1 flag)")
    print(f"Search space: 2^{num_data_qubits} = {2**num_data_qubits:,} configurations")
    
    adjacencies = get_adjacencies(rows, cols)
    print(f"Adjacency constraints: {len(adjacencies)}")
    
    # Warning for large grids
    if num_data_qubits > 20:
        print("\n⚠️  WARNING: Large grid detected!")
        print(f"   This will require {num_qubits} qubits and may be slow to simulate.")
        response = input("   Continue? (y/n): ")
        if response.lower() != 'y':
            print("Aborted.")
            return
    
    # Build circuit
    qc = QuantumCircuit(num_qubits, num_data_qubits)
    data = list(range(num_data_qubits))
    flag = num_data_qubits
    
    # Initialize superposition
    qc.h(data)
    qc.x(flag)
    qc.h(flag)
    
    # Calculate optimal iterations
    num_iterations = calculate_iterations(num_tiles)
    print(f"Grover iterations: {num_iterations}")
    
    # Apply Grover iterations
    print("\nRunning Grover's algorithm...")
    for iteration in range(num_iterations):
        grover_oracle(qc, data, flag, adjacencies)
        diffuser(qc, data)
        if (iteration + 1) % max(1, num_iterations // 5) == 0:
            print(f"  Progress: {iteration + 1}/{num_iterations} iterations")
    
    # Measure
    qc.measure(data, range(num_data_qubits))
    
    # Run simulation
    print("Running quantum simulation...")
    backend = Aer.get_backend("qasm_simulator")
    result = backend.run(qc, shots=8192).result()
    counts = result.get_counts()
    
    # Analyze results
    valid_counts = {k: v for k, v in counts.items() if is_valid_grid(k, adjacencies)}
    invalid_counts = {k: v for k, v in counts.items() if not is_valid_grid(k, adjacencies)}
    
    total_valid = sum(valid_counts.values())
    total_invalid = sum(invalid_counts.values())
    
    print(f"\n{'='*60}")
    print("RESULTS")
    print(f"{'='*60}")
    print(f"Valid configurations: {total_valid}/{total_valid+total_invalid} ({100*total_valid/(total_valid+total_invalid):.1f}%)")
    print(f"Invalid configurations: {total_invalid}/{total_valid+total_invalid} ({100*total_invalid/(total_valid+total_invalid):.1f}%)")
    print(f"Unique valid grids found: {len(valid_counts)}")
    
    if not valid_counts:
        print("\n⚠️  No valid solutions found!")
        print("Try increasing iterations or checking adjacency rules.")
        valid_counts = counts
    
    # Find best solution
    best = max(valid_counts, key=valid_counts.get)
    tiles = [best[i:i+2] for i in range(0, len(best), 2)]
    decoded = [TILE_MAP[t] for t in tiles]
    
    print(f"\nBest solution bitstring: {best}")
    print(f"Count: {valid_counts[best]} shots ({100*valid_counts[best]/sum(valid_counts.values()):.1f}%)")
    print(f"Is valid: {is_valid_grid(best, adjacencies)}")
    
    # Display grid
    print(f"\nDecoded {rows}×{cols} grid:")
    for row in range(rows):
        row_tiles = decoded[row*cols:(row+1)*cols]
        print(f"  {row_tiles}")
    
    # Verify adjacencies
    print("\nAdjacency validation:")
    all_valid = True
    for a, b in adjacencies:
        is_valid = decoded[b] in VALID[decoded[a]]
        status = "✓" if is_valid else "✗"
        print(f"  {status} Pos {a}({decoded[a]}) → Pos {b}({decoded[b]})")
        if not is_valid:
            all_valid = False
    
    if all_valid:
        print("\n✅ All adjacencies are valid!")
    else:
        print("\n❌ Some adjacencies are invalid!")
    
    # Visualizations
    visualize_results(valid_counts, decoded, rows, cols, adjacencies, best)
    
    return qc, counts, decoded

# --------------------------------------------------
# Visualization
# --------------------------------------------------
def visualize_results(valid_counts, decoded, rows, cols, adjacencies, best):
    # Plot histogram
    sorted_valid = dict(sorted(valid_counts.items(), key=lambda x: x[1], reverse=True)[:20])
    fig = plot_histogram(sorted_valid)
    plt.title(f"Top 20 Valid WFC Configurations ({rows}×{cols} grid)")
    plt.tight_layout()
    plt.show()
    
    # Plot grid
    grid = np.zeros((rows, cols, 3))
    for i, tile in enumerate(decoded):
        r = i // cols
        c = i % cols
        grid[r, c] = COLOR_MAP[tile]
    
    fig, ax = plt.subplots(figsize=(max(6, cols*2), max(6, rows*2)))
    ax.imshow(grid, interpolation='nearest')
    ax.axis("off")
    
    # Add tile labels
    for i, tile in enumerate(decoded):
        r = i // cols
        c = i % cols
        ax.text(c, r, f"{i}\n{tile}", ha='center', va='center', 
                fontsize=max(8, 12-max(rows,cols)), color='white', weight='bold',
                bbox=dict(boxstyle='round', facecolor='black', alpha=0.6))
    
    # Grid lines
    for i in range(rows + 1):
        ax.axhline(i - 0.5, color='black', linewidth=2)
    for j in range(cols + 1):
        ax.axvline(j - 0.5, color='black', linewidth=2)
    
    title_color = 'green' if is_valid_grid(best, adjacencies) else 'red'
    
    # Format title based on grid size
    if rows <= 3 and cols <= 3:
        grid_str = '\n'.join([str(decoded[row*cols:(row+1)*cols]) for row in range(rows)])
        ax.set_title(f"{rows}×{cols} WFC Grid\n{grid_str}", 
                     fontsize=11, color=title_color, weight='bold')
    else:
        ax.set_title(f"{rows}×{cols} WFC Grid", 
                     fontsize=14, color=title_color, weight='bold')
    
    plt.tight_layout()
    plt.show()

# --------------------------------------------------
# Run the algorithm
# --------------------------------------------------
if __name__ == "__main__":
    circuit, counts, solution = run_wfc_grover(GRID_ROWS, GRID_COLS)